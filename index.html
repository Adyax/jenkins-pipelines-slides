<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">


<section data-markdown><script type="text/template">
## JENKINS 2 PIPELINES AS A CONTINUOUS INTEGRATION / DELIVERY / DEPLOYMENT PLATFORM FOR DRUPAL

---

Alexander Tolstikov | Aleksey Tkachenko

Adyax 2016

<img data-src="images/pipeline.png">

<aside class="notes">
I want to present our session named JENKINS 2 PIPELINES AS A CONTINUOUS INTEGRATION PLATFORM FOR DRUPAL. The name for this session is not very correct as we are going to show you much more interesting stuff then just Continuous Integration. You'll have some theory first and than we'll show you some real examples of using pipelines.
</aside>
</script></section>

<section>
<h2>Software delivery & deployment pipeline (AN)</h2>
<p class="fragment grow">Build</p>
<p class="fragment grow">Deploy</p>
<p class="fragment grow">Test</p>
<p class="fragment grow">Release</p>
<p>Deployment pipeline is the automated implementation of these steps.<p>
<aside class="notes">
- The goal of any software development process is to deliver some product to the end users.
- We want to deliver a changes to users in fast, reliable way from development to release.
</aside>
</section>

<section>
<h2>Software release antipatterns</h2>
<p class="fragment grow">Manual deploys</p>
<p class="fragment grow">Long release cycles</p>
<p class="fragment grow">Manual configuration of environments</p>
<aside class="notes">
You should only choose version number and click deploy.
</aside>
</section>

<section>
<h2>
Release process should be
</h2>
<p class="fragment">frequent</p>
<p class="fragment">automated</p>
<p class="fragment">repeatable</p>
<p class="fragment">lowrisk</p>
<p class="fragment">cheap</p>
<p class="fragment">fast</p>
<p class="fragment">predictable</p>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Principles of successfull software delivery
</h2>
<p class="fragment">
Repeatable and reliable process
</p>
<p class="fragment">
Automate (almost) everything
</p>
<p class="fragment">
Put everything in version control
</p>
<p class="fragment">
If it hurts - do it more frequently
</p>
<p class="fragment">
Done means released
</p>
<p class="fragment">
</p>
<p class="fragment">
Everybody is responsible
</p>
<aside class="notes">
Releasing software should be easy. It should be easy because you have tested every single part of the release process hundreds of times before. It should be as simple as pressing a button. The repeatability and reliability derive from two principles: automate almost everything, and keep everything you need to build, deploy, test, and release your application in version control.
</aside>
</section>

<section>
<h2>
Continuous Integration
</h2>
Continuous Integration (CI) is the practice of merging all developer working copies to a shared mainline several times a day.
<aside class="notes">
</aside>
</section>

<section>
<h2>
Continuous Delivery
</h2>
<p>Continuous Delivery (CD) is a software strategy that enables organizations to deliver new features to users as fast and efficiently as possible.</p>

<p>"Continuous Delivery is a software development discipline where you build software in such a way that the software can be released to production at any time" - Martin Fowler.</p>

<p>"Continuous Delivery aims to reduce the cost, time, and risk of delivering incremental changes to users" - Jez Humble.</p>
<aside class="notes">
Continuous delivery is sometimes confused with continuous deployment. Continuous deployment means that every change is automatically deployed to production. Continuous delivery means that the team ensures every change can be deployed to production but may choose not to do it, usually due to business reasons. In order to do continuous deployment one must be doing continuous delivery
</aside>
</section>

<section>
<h2>
Continuous Delivery & Feature Branches
</h2>
<p>Every successful build on your Master branch should be releasable.</p>
<p>Your feature branches get merged into master, when they have been tested.</p>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Continuous Deployment
</h2>
Continuous deployment is the next step of continuous delivery: Every change that passes the automated tests is deployed to production automatically.
<aside class="notes">
</aside>
</section>

<section>
<h2>
What is (deployment) pipeline
</h2>
<blockquote>
"A deployment pipeline is a way to break up your build into stages."
</blockquote>
<blockquote>
"Deployment pipelines are a central part of Continuous Delivery"
</blockquote>
<p>Martin Fowler</p>
- Glue code
<aside class="notes">
- This is a very clean description of pipelines.
- Why we need to break up pipeline into stages? Because we want to have faster feedback.
- We can also think about pipelines as a glue code.
</aside>
</section>

<section>
<h2>
The goal of deployment pipeline (TBE, AN)
</h2>
<p class="fragment">it makes every part of the process of building, deploying, testing, and releasing software visible to everybody involved, aiding collaboration.</p>

<p class="fragment"> it improves feedback so that problems are identified, and so resolved, as early in the process as possible.</p>

<p class="fragment"> it enables teams to deploy and release any version of their software to any environment at will through a fully automated process.</p>

<aside class="notes">
</aside>
</section>

<section>
<h2>
Why we need pipelines?
</h2>
<p class="fragment">Detect any changes that could lead to problems in Production:<br/>
<i>Security, Performance, Usability, etc</i><p>

<p class="fragment">Enable collaboration between the various groups involved in delivering software</p>

<p class="fragment">Provide visibility about the flow of changes</p>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Deploy pipelines in Jenkins
</h2>
<p class="fragment">
Enabled by "Pipeline" plugin (formerly known as "Workflow")
</p>
<p class="fragment">
Based on Pipeline DSL (Domain-specific language)
</p>
<p class="fragment">
Pipeline DSL is based on Groovy programming language
</p>
<p class="fragment">
<strong>Resilent</strong> - can survive restarts
</p>
<p class="fragment">
<strong>Pausable</strong> - can pause and wait for human input/approval
</p>
<p class="fragment">
<strong>Efficient</strong> - can restart from saved checkpoints (in paid Jenkins version)
</p>
<p class="fragment">
<strong>Visualized</strong> - provides status at-a-glance
</p>

<aside class="notes">
</aside>
</section>

<section>
<h2>
Pipeline anatomy
</h2>
<p class="fragment">
<strong>Step</strong> - Single task that is a part of the sequence
</p>
<p class="fragment"><strong>Node</strong> - Step that schedules steps contained within it into Jenkins build queue and allocates the workspace.
</p>
<p class="fragment">
<strong>Stage</strong> - Contains steps inside and have some additional configuration
</p>
<aside class="notes">
</aside>
</section>

<section style="padding: 0px; margin: 0px">
<h2>
Simple pipeline
</h2>
<div style="width: 100%">
<div style="width: 47%; display: inline-block; vertical-align: top;">
Pipeline code
<pre><code>
node {
    stage('hello') {
        echo 'Hello Drupalcon!'
    }

    stage('build') {
        echo "Give me a current directory"
        sh('pwd')
    }
}
</code></pre>
</div>

<div style="width: 47%; display: inline-block; vertical-align: top;">
Pipeline log
<pre><code>
[Pipeline] {
[Pipeline] stage
[Pipeline] { (hello)
[Pipeline] echo
Hello Drupalcon!
[Pipeline] }
[Pipeline] // stage
[Pipeline] stage
[Pipeline] { (build)
[Pipeline] echo
Give me a current directory
[Pipeline] sh
[simple] Running shell script
+ pwd
/var/jenkins_home/workspace/simple/simple
[Pipeline] }
[Pipeline] // stage
[Pipeline] }
[Pipeline] // node
[Pipeline] End of Pipeline
</code></pre>
</div>
</div>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Drupal Composer workflow : Why?
</h2>
...<br />
This is a future.
<aside class="notes">
</aside>
</section>

<section>
<h2>
Drupal Composer workflow : Requirements
</h2>
<p class="fragment">
Requirement: You should NOT commit "vendor" (drupal core & contrib packages) to source control with proper Composer workflow
</p>
<p class="fragment">
Requirement: You should NOT run "composer update" on Production as you want same version of code as in Development
</p>
<p class="fragment">
Requirement:  You should NOT run "composer install" on Production, because:<br/>
It can be failed because of timeouts/other issues<br />
You need to test built code before it hits Production<br />
It can take a long time
</p>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Drupal Composer workflow : Problem
</h2>
<p class="fragment">
How to deliver result of the build to the Production without commiting vendor code into Source control or executing "compose install" directly on Production servers?
</p>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Drupal Composer workflow : Solution
</h2>
Continuous Delivery workflow with delivery options:
<ul>
<li>
Option 1: With tarball, capistrano, sync, etc.
This solution will not work with major Drupal hosting/service providers, like Acquia, because code should be delivered through Git repo.
</li>
<li>
Option 2: With additional Git repository (target repo).<br/>
Commit to source repo -> CI (Jenkins) -> Build (sh "composer install") -> Commit to target repo -> Deploy to target environment
 - TODO: PUT SCHEME HERE
</li>
</ul>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Drupal Composer workflow : Tools
</h2>
<ul>
<li>
Docman - DOCroot MANagement
</li>
<li>
Composer - composer workflow
</li>
<li>
Druflow - deploy procedures and drupal-procedures Swiss-knife
</li>
<li>
Behat - testing framework
</li>
<li>
Pipeline - to orchestrate it all
</li>
</ul>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Job DSL plugin
</h2>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Job DSL plugin
</h2>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Job DSL plugin
</h2>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Pipeline Libraries
</h2>
- Global library
- External libraries

<aside class="notes">
</aside>
</section>

<section>
<h2>
Job DSL plugin
</h2>
<aside class="notes">
</aside>
</section>

<section>
<h2>
BlueOcean plugin
</h2>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Slide
</h2>
<aside class="notes">
</aside>
</section>

<section>
<h2>
Slide
</h2>
<aside class="notes">
</aside>
</section>

<section>
<h2>Build Stage</h2>
<img data-src="images/buildStage.png">
</section>

<section>
<h2>
Slide
</h2>
<aside class="notes">
</aside>
</section>




			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				// showNotes: true,
				history: true,
				//width: 1400,
    				//height: 700,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
